# Bedrock Rust Proxy - Cursor Rules

## Project Overview

This project implements a Minecraft Bedrock Edition proxy in Rust that:
- Intercepts and forwards packets between clients and servers
- Logs all packets in binary format (one file per session)
- Provides a terminal-based viewer for browsing and analyzing packet logs
- Supports protocol decoding to show human-readable packet information

## Key Requirements

1. **Proxy Functionality**
   - UDP-based packet forwarding between client and upstream server
   - Session management (one log file per client session)
   - Binary packet logging with protocol version tracking

2. **Packet Logging**
   - One binary file per session (UUID-based naming)
   - Length-prefixed bincode serialization format
   - Protocol version stored with each packet
   - Uncompressed format (compression removed per user request)

3. **Packet Viewer**
   - Terminal UI (ratatui + crossterm)
   - Session log browsing
   - Packet navigation with timeline visualization
   - Scrollable packet details panel
   - JSON and hex view modes
   - Protocol version display
   - Packet name and ID identification

4. **Protocol Decoding**
   - Load protocol definitions from minecraft-data (proto.yml format)
   - Extract packet IDs using varint decoding
   - Identify packet names from protocol definitions
   - Display decoded packet information in viewer

## Technology Stack

- **Async Runtime**: `tokio` with full features
- **Serialization**: `bincode` for binary logs, `serde_json` for JSON output
- **Terminal UI**: `ratatui` (formerly tui-rs) and `crossterm`
- **Protocol Parsing**: `serde_yaml` for YAML protocol definitions
- **Error Handling**: `anyhow` for context-rich errors, `thiserror` for error types
- **Logging**: `tracing` and `tracing-subscriber` with env-filter support
- **Network**: Native UDP sockets with `tokio::net::UdpSocket`

## Architecture Patterns

### UDP Proxy Architecture
- **Single Socket Approach**: Use one `Arc<UdpSocket>` for both client and upstream communication
- **Address-Based Dispatch**: Route packets based on source address (client vs upstream)
- **Correct UDP Usage**: Always use `send_to()` with explicit destination address, never `send()` or `connect()`

### Packet Logging
- **Format**: `[u32 length (little-endian)][bincode-serialized PacketEntry]`
- **Session Management**: UUID-based session IDs, one logger per session
- **Protocol Versioning**: Store protocol version with each packet for compatibility

### Protocol Parsing
- **Definition Source**: Extract from `minecraft-data` npm package (proto.yml files)
- **Parser Structure**: Load once at viewer startup, reuse for all packets
- **Graceful Degradation**: Viewer works even if protocol parser fails to load

### Terminal UI
- **State Management**: Clear separation between session list and packet view modes
- **Scroll Management**: Track scroll state per-packet, reset on navigation
- **Focus Management**: Removed (simplified to direct key controls per panel)
- **Error Display**: In-app error messages shown in UI

## Debugging Patterns and Best Practices

### Error Visibility
- Always log errors with context using `anyhow::Context`
- Default log level is INFO if `RUST_LOG` not set
- Use `debug!` for verbose packet activity, `info!` for important events
- Display errors in UI when appropriate (e.g., viewer error messages)

### Network Debugging
- **Socket Simplification**: Single UDP socket approach simplifies forwarding
- **UDP Socket Methods**: Always use `send_to()` with explicit address, never `connect()` or `send()` on UDP sockets
- **Error Context**: Include socket addresses and packet sizes in error messages

### Binary Data Handling
- **Length Prefixes**: Always prefix serialized data with length for reliable deserialization
- **Format Versioning**: Support both old and new log formats with fallback parsing
- **Sanity Checks**: Validate length prefixes (max size, remaining data availability)

### Protocol Parsing
- **Graceful Loading**: Protocol parser should fail gracefully if definition files missing
- **Version Matching**: Use closest available protocol version if exact match unavailable
- **Varint Parsing**: Implement proper varint decoding for packet IDs (support multi-byte)

### Code Organization
- **Module Structure**: Separate concerns (proxy, session, packet_logger, protocol, viewer)
- **Binary Targets**: Use separate binaries for different tools (viewer, log_reader, main proxy)
- **Library Code**: Shared code (packet_logger, protocol) accessible via lib.rs

### Testing Approach
- **Incremental Testing**: Test each component as features are added
- **Error Handling**: Tests should verify graceful error handling
- **Backward Compatibility**: Always test with old log formats when making changes

## Development Workflow

### Adding Protocol Support
1. Extract protocol definitions from minecraft-data to `data/protocol/`
2. Update `ProtocolParser` to handle new version
3. Test packet ID extraction and name lookup
4. Implement field decoding incrementally (simple types first)

### Adding Viewer Features
1. Update `ViewerApp` state structure
2. Modify rendering functions for new UI elements
3. Add keyboard handlers for new controls
4. Test scrolling and navigation edge cases

### Logging Format Changes
1. Add new fields to `PacketEntry` with `#[serde(default)]` for backward compatibility
2. Update log reading code to handle both old and new formats
3. Test with existing log files to ensure compatibility

### Adding Database Functionality (Database-First Changes)

#### Step 1: Add Database Functions (`apps/lazypacket/src/db.rs`)
- Add async functions to `Database` impl block
- Functions should return `Result<T>` and use `.context()` for error messages
- Follow existing patterns (e.g., `get_sessions()`, `get_packets()`)
- Use parameterized queries with `$1`, `$2`, etc. for safety
- Example pattern:
  ```rust
  pub async fn new_function(&self, param: Type) -> Result<ReturnType> {
      let rows = self.client
          .query("SELECT ... WHERE id = $1", &[&param])
          .await
          .context("Failed to query ...")?;
      // Process rows and return
  }
  ```

#### Step 2: Update Schema/DDL (if needed)
- Update `apps/relay/.ddl/schema.sql` for new tables/columns
- Create migration file in `apps/relay/.ddl/` following naming pattern `NN_migrate_description.sql`
- Migration files should be idempotent (use `IF NOT EXISTS`, `ON CONFLICT DO NOTHING`, etc.)

### Adding UI Features (UI-First Changes)

#### Step 1: Define State Structures
- Add new mode to `ViewerMode` enum if needed (e.g., `TagManagement`, `ConfirmationDialog`)
- Create state structs for modals/management views:
  ```rust
  struct FeatureState {
      // State fields
  }
  ```
- Add state to `ViewerApp` struct:
  ```rust
  feature_state: Option<FeatureState>,
  ```

#### Step 2: Add Confirmation Actions (if using confirmation dialog)
- Add variant to `ConfirmationAction` enum:
  ```rust
  enum ConfirmationAction {
      DeleteTag { session_id: i32, tag: String },
      DeleteSession { session_id: i32 },
      // Add new actions here
  }
  ```
- Add `confirmation_dialog: Option<ConfirmationDialogState>` to `ViewerApp` if not present

#### Step 3: Initialize State in `ViewerApp::new()`
- Initialize new state fields (usually `None` or empty)
- Load initial data if needed (e.g., tags for sessions)

#### Step 4: Add Keyboard Handlers
- Add handler in main event loop matching on `app.mode`
- For new modes, add `match` branch:
  ```rust
  ViewerMode::NewMode => {
      match key.code {
          KeyCode::Esc => { /* cleanup and return */ }
          // Handle other keys
      }
  }
  ```
- For confirmation dialog:
  ```rust
  ViewerMode::ConfirmationDialog => {
      match key.code {
          KeyCode::Esc | KeyCode::Char('n') => { /* cancel */ }
          KeyCode::Enter | KeyCode::Char('y') => {
              // Execute action based on ConfirmationAction variant
          }
      }
  }
  ```

#### Step 5: Create Rendering Functions
- Create rendering function: `fn render_feature(f: &mut Frame, app: &mut ViewerApp)`
- Use `centered_rect()` helper for modals (percentage width/height)
- For confirmation dialog: `fn render_confirmation_dialog(f: &mut Frame, app: &mut ViewerApp)`
- Update `ui()` function to route to new renderer based on mode

#### Step 6: Update Help Text
- Update help text in relevant UI components to show new keyboard shortcuts
- Example: Session list title includes "d to delete, t to tag"

### Reusable Patterns

#### Confirmation Dialog Pattern
1. Set `confirmation_dialog` state with message and action:
   ```rust
   app.confirmation_dialog = Some(ConfirmationDialogState {
       message: format!("Confirm action?"),
       action: ConfirmationAction::ActionType { params },
   });
   app.mode = ViewerMode::ConfirmationDialog;
   ```
2. Handle confirmation in `ConfirmationDialog` mode handler
3. Dialog renders as overlay on underlying view
4. After confirmation, return to appropriate mode (check `tag_management` or default to `SessionList`)

#### Modal Pattern
1. Create state struct with fields needed for modal
2. Add `Option<StateStruct>` to `ViewerApp`
3. Initialize state when entering modal (e.g., load data)
4. Create rendering function that uses `centered_rect()` for positioning
5. Handle keyboard input in modal mode
6. Clean up state when closing modal

#### List Navigation Pattern
- Use `selected_index` in state struct
- Handle `Up`/`Down` keys to adjust index
- Clamp index: `index.min(list.len().saturating_sub(1))`
- Handle empty list case

### Common Pitfalls to Avoid

1. **Borrow Checker Issues**: When calling methods that need mutable `app` borrow while holding mutable borrow of nested state, extract values first:
   ```rust
   let session_id = tag_mgmt.session_id; // Extract before async call
   app.db.operation(session_id).await?; // Now safe
   ```

2. **State Cleanup**: Always clean up modal state when closing (set to `None`)

3. **Index Bounds**: Always check bounds when adjusting selected indices after deletions

4. **Mode Transitions**: Ensure mode transitions are clear and don't leave dangling state

5. **Error Handling**: Show errors in `error_message` field, don't silently fail

6. **UI Updates**: After database operations, refresh both in-memory state and session list if needed

## Configuration

### Environment Variables
- `RUST_LOG`: Controls log verbosity (defaults to "info" if not set)
  - Examples: `RUST_LOG=debug`, `RUST_LOG=bedrock_rust_proxy=debug`

### Default Settings
- Protocol version: 1.21.111 (closest to target 1.21.113)
- Log directory: `logs/`
- Proxy listen address: `0.0.0.0:19332`
- Upstream address: `192.168.1.100:19132` (configurable)

## Current Limitations

1. **Protocol Decoding**: Only packet identification works (name/ID), field decoding not yet implemented
2. **RakNet Headers**: Packet ID extraction assumes raw packet data, doesn't parse RakNet headers
3. **Multiple Versions**: Only one protocol version supported at a time
4. **YAML Parsing**: Some edge cases in proto.yml parsing may need refinement

## Future Enhancements

1. Full packet field decoding with all type support
2. Multiple protocol version support with automatic matching
3. Packet filtering and search capabilities
4. Protocol-aware packet validation
5. Export functionality for decoded packets
